{
  "name": "Angellandros Projects Wiki",
  "tagline": "Muhammad-Ali A'rabi Github Homepage",
  "body": "ΑΓΕΩΜΕΤΡΗΤΟΣ ΜΗΔΕΙΣ ΕΙΣΙΤΩ\r\n\r\n## Scala Wars\r\nThis side of the page is dedicated to Scala programming language.\r\n\r\n### H2H Scala Course, CafeBazaar\r\n\r\n__Exercise 1.__\r\nWhat is the problem with this anonymous function?\r\n```scala\r\nval l = (1 to 5).toList\r\nl foreach { println(_*2) }\r\n```\r\n\r\n__Exercise 2.__\r\nWrite a code in Scala which estimates `Pi = 3.14`. The code should scan an integer from `stdin`, which is the number of iterations. Do it with `val n = readLine.toInt`.\r\nUse <ideone.com> to compile and test the code, and share the link after you have succeeded.\r\nYou can use `scala.util.Random` class in your code if you want:\r\n```scala\r\nimport scala.util.Random\r\n\r\nobject Main extends App {\r\n    val r = Random()\r\n    val n = readLine().toInt\r\n    ...\r\n    val someRandomDouble = r.nextDouble()  // generates a double between 0.0 and 1.0\r\n    ...\r\n    println(pi)\r\n}\r\n```\r\n\r\n### Scala Cheatsheet\r\n\r\n#### Values\r\n\r\nScala immutable names\r\n\r\n```scala\r\n    val n = 21          // type automatically assigned as Int\r\n    val d: Double = 21  // explicit type declaration\r\n```\r\n\r\nYou cannot reassign to values, but you can redefine them:\r\n\r\n```scala\r\n    val two = 2  // first assignment\r\n    two = 3      // causes error: reassignment to val\r\n    val two = 3  // works fine\r\n```\r\n\r\nA value could not be reassigned, but can contain a pointer to a mutable object:\r\n\r\n```scala\r\n    val jhm = new java.util.HashMap[Int, String]()  // a pointer to the mutable object is assigned to jhm\r\n    jhm.set(1, \"one\")                               // works fine\r\n    \r\n    val mhm = new scala.collection.mutable.HashMap[Int, String]()\r\n    mhm = mhm + (2 -> \"two)  // causes error: reassignment to val\r\n    mhm += (2 -> \"two\")      // works fine, because  +=  is a member of mutable HashMap class\r\n```\r\n\r\n#### Variables\r\n\r\nScala names that can vary, same as C++ variable\r\n\r\n```scala\r\n    var n = 5\r\n    n = 6\r\n    \r\n    var l = List(1, 2, 3)\r\n    l += 4         // error\r\n    l = l.drop(2)  // fine\r\n```\r\n\r\n#### Functions\r\n\r\nCallable things\r\n\r\n```scala\r\n    // classic function\r\n    def f(a: Int): Double = {\r\n      var returnValue: Double = 0\r\n      ...\r\n      returnValue  // last line is returned\r\n    }\r\n    \r\n    def square(a: Int) = { a*a }      // no explicit return type\r\n    def triple(a: Int) = 3*a          // no braces\r\n    def sum(a: Int*) = a.reduce(_+_)  // function with varargs\r\n    def one() = 1                     // no arguments\r\n    def two = 2                       // no parentheses\r\n```\r\n\r\n##### Anonymous Function\r\n\r\nFunctions with no name\r\n\r\n```scala\r\n    (x: Int) => x*x  // no name\r\n    x => x*x         // no argument type, when there is no ambiguation\r\n    2*_              // underscore as once-used argument, when there is no ambiguation in the type of argument\r\n    _*_              // same as (a, b) => a*b\r\n    \r\n    import scala.language.postfixOps\r\n    2*               // same as _*2 or 2*_, *2 won't work since * is a postfix operator returning a function\r\n```\r\n\r\n##### Type of Functions\r\n\r\nA function `(a1: T1, ... , an: Tn): T` has the type `(T1, ... , Tn) => T`:\r\n\r\n```scala\r\n    def f(a: Int) = a.toString           // f has the type Int => String\r\n    def add(a: Double, b: Double) = a+b  // has the type (Double, Double) => Double\r\n```\r\n\r\n##### Higher Order Functions\r\n\r\nAre functions that return functions:\r\n\r\n```scala\r\n    def f(a: Int) = {\r\n      def g(b: Int) = a*b\r\n      g _  // return g of the type Int => Int\r\n    }\r\n    \r\n    def f(a: Int) = (b: Int) => a*b       // same function\r\n    def f(a: Int): Int => Int = b => a*b  // same function\r\n    def f(a: Int): Int => Int = a*_       // same function\r\n    \r\n    import scala.language.postfixOps\r\n    def f(a: Int): Int => Int = a*        // same function\r\n```\r\n\r\n##### Currying\r\n\r\nConverting a function with multiple arguments into a function with a\r\nsingle argument that returns another function:\r\n\r\n```scala\r\n    def f(a: Int, b: Int): Int // uncurried version (type is (Int, Int) => Int)\r\n    def f(a: Int)(b: Int): Int // curried version (type is Int => Int => Int)\r\n```\r\n\r\n#### Evaluation Rules\r\n\r\n- Call by value: evaluates the function arguments before calling the function\r\n- Call by name: evaluates the function first, and then evaluates the arguments if need be\r\n\r\n```scala\r\n    def example = 2      // evaluated when called\r\n    val example = 2      // evaluated immediately\r\n    lazy val example = 2 // evaluated once when needed\r\n    \r\n    def square(x: Double)    // call by value\r\n    def square(x: => Double) // call by name\r\n    def myFct(bindings: Int*) = { ... } // bindings is a sequence of int, containing a varying # of arguments\r\n```",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}